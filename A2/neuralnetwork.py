{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# A2.5 Multilayer Neural Networks for Nonlinear Regression\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Sebastian Infantes"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Summary"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "In this assignment you will \n",
    "* make some modifications to the supplied neural network implementation, \n",
    "* define a function that partitions data into training, validation and test sets,\n",
    "* apply it to a data set, \n",
    "* define a function that runs experiments with a variety of parameter values, \n",
    "* describe your observations of these results."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Optimizers"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "First, we need a class that includes our optimization algorithms, `sgd` and `adam`.  The following code cell implements `sgd`.  You must complete the implementation of `adam`, following its implementation in the lecture notes.\n",
    "\n",
    "Notice that `all_weights` is updated in place by these optimization algorithms.  The new values of `all_weights` are not returned from these functions, because the code that calls these functions allocates the memory for `all_weights` and keeps the reference to it so has direct access to the new values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "class Optimizers():\n",
    "\n",
    "    def __init__(self, all_weights):\n",
    "        '''all_weights is a vector of all of a neural networks weights concatenated into a one-dimensional vector'''\n",
    "        \n",
    "        self.all_weights = all_weights\n",
    "\n",
    "        # The following initializations are only used by adam.\n",
    "        # Only initializing mt, vt, beta1t and beta2t here allows multiple calls to adam to handle training\n",
    "        # with multiple subsets (batches) of training data.\n",
    "        self.mt = np.zeros_like(all_weights)\n",
    "        self.vt = np.zeros_like(all_weights)\n",
    "        self.beta1 = 0.9\n",
    "        self.beta2 = 0.999\n",
    "        self.beta1t = 1  # was self.beta1\n",
    "        self.beta2t = 1  # was self.beta2\n",
    "\n",
    "        \n",
    "    def sgd(self, error_f, gradient_f, fargs=[], n_epochs=100, learning_rate=0.001, error_convert_f=None):\n",
    "        '''\n",
    "error_f: function that requires X and T as arguments (given in fargs) and returns mean squared error.\n",
    "gradient_f: function that requires X and T as arguments (in fargs) and returns gradient of mean squared error\n",
    "            with respect to each weight.\n",
    "error_convert_f: function that converts the standardized error from error_f to original T units.\n",
    "        '''\n",
    "\n",
    "        error_trace = []\n",
    "        epochs_per_print = n_epochs // 10\n",
    "\n",
    "        for epoch in range(n_epochs):\n",
    "\n",
    "            error = error_f(*fargs)\n",
    "            grad = gradient_f(*fargs)\n",
    "\n",
    "            # Update all weights using -= to modify their values in-place.\n",
    "            self.all_weights -= learning_rate * grad\n",
    "\n",
    "            if error_convert_f:\n",
    "                error = error_convert_f(error)\n",
    "            error_trace.append(error)\n",
    "\n",
    "            if (epoch + 1) % max(1, epochs_per_print) == 0:\n",
    "                print(f'sgd: Epoch {epoch+1:d} Error={error:.5f}')\n",
    "\n",
    "        return error_trace\n",
    "\n",
    "    def adam(self, error_f, gradient_f, fargs=[], n_epochs=100, learning_rate=0.001, error_convert_f=None):\n",
    "        '''\n",
    "error_f: function that requires X and T as arguments (given in fargs) and returns mean squared error.\n",
    "gradient_f: function that requires X and T as arguments (in fargs) and returns gradient of mean squared error\n",
    "            with respect to each weight.\n",
    "error_convert_f: function that converts the standardized error from error_f to original T units.\n",
    "        '''\n",
    "        \n",
    "        # adam = Adaptive Moment Estimation\n",
    "\n",
    "        alpha = learning_rate  # learning rate called alpha in original paper on adam\n",
    "        epsilon = 1e-8\n",
    "        error_trace = []\n",
    "        epochs_per_print = n_epochs // 10\n",
    "\n",
    "        for epoch in range(n_epochs):\n",
    "\n",
    "            error = error_f(*fargs)\n",
    "            grad = gradient_f(*fargs)\n",
    "\n",
    "            # Finish Adam implementation here by updating\n",
    "            #   self.mt\n",
    "            #   self.vt\n",
    "            #   self.beta1t\n",
    "            #   self.beta2t\n",
    "            # and updating values of self.all_weights\n",
    "            \n",
    "            # mt = beta1 * mt + (1 - beta1) * gradE_W\n",
    "            gradE_W = learning_rate * grad\n",
    "            self.mt = self.beta1 * self.mt + (1 - self.beta1) * (gradE_W)\n",
    "            \n",
    "            # vt = beta2 * vt + (1 - beta2) * np.square(gradE_W)\n",
    "            self.vt = self.beta2 * self.vt + (1 - self.beta2) * np.square(gradE_W)\n",
    "            \n",
    "            # beta1t *= beta1\n",
    "            self.beta1t *= self.beta1\n",
    "            \n",
    "            # beta2t *= beta2\n",
    "            self.beta2t *= self.beta2\n",
    "            \n",
    "            # mhat = mt / (1 - beta1)\n",
    "            mhat = self.mt / (1 - self.beta1t)\n",
    "            \n",
    "            # vhat = vt / (1 - beta2)\n",
    "            vhat = self.vt / (1 - self.beta2t)\n",
    "            \n",
    "            # w -= rho * mhat / (np.sqrt(vhat) + epsilon)\n",
    "            # rho = learning rate?\n",
    "            self.all_weights -= learning_rate * mhat / (np.sqrt(vhat) + epsilon)\n",
    "        \n",
    "\n",
    "            if error_convert_f:\n",
    "                error = error_convert_f(error)\n",
    "            error_trace.append(error)\n",
    "\n",
    "            if (epoch + 1) % max(1, epochs_per_print) == 0:\n",
    "                print(f'Adam: Epoch {epoch+1:d} Error={error:.5f}')\n",
    "\n",
    "        return error_trace"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Test `Optimizers` using the function `test_optimizers`.  You should get the same results shown below."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "def test_optimizers():\n",
    "\n",
    "    def parabola(wmin):\n",
    "        return ((w - wmin) ** 2)[0]\n",
    "\n",
    "    def parabola_gradient(wmin):\n",
    "        return 2 * (w - wmin)\n",
    "\n",
    "    w = np.array([0.0])\n",
    "    optimizer = Optimizers(w)\n",
    "\n",
    "    wmin = 5\n",
    "    optimizer.sgd(parabola, parabola_gradient, [wmin], n_epochs=100, learning_rate=0.1)\n",
    "    print(f'sgd: Minimum of parabola is at {wmin}. Value found is {w}')\n",
    "\n",
    "    w = np.array([0.0])\n",
    "    optimizer = Optimizers(w)\n",
    "    optimizer.adam(parabola, parabola_gradient, [wmin], n_epochs=100, learning_rate=0.1)\n",
    "    print(f'adam: Minimum of parabola is at {wmin}. Value found is {w}')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sgd: Epoch 10 Error=0.45036\n",
      "sgd: Epoch 20 Error=0.00519\n",
      "sgd: Epoch 30 Error=0.00006\n",
      "sgd: Epoch 40 Error=0.00000\n",
      "sgd: Epoch 50 Error=0.00000\n",
      "sgd: Epoch 60 Error=0.00000\n",
      "sgd: Epoch 70 Error=0.00000\n",
      "sgd: Epoch 80 Error=0.00000\n",
      "sgd: Epoch 90 Error=0.00000\n",
      "sgd: Epoch 100 Error=0.00000\n",
      "sgd: Minimum of parabola is at 5. Value found is [5.]\n",
      "Adam: Epoch 10 Error=16.85565\n",
      "Adam: Epoch 20 Error=9.93336\n",
      "Adam: Epoch 30 Error=5.21627\n",
      "Adam: Epoch 40 Error=2.37740\n",
      "Adam: Epoch 50 Error=0.90515\n",
      "Adam: Epoch 60 Error=0.26972\n",
      "Adam: Epoch 70 Error=0.05453\n",
      "Adam: Epoch 80 Error=0.00453\n",
      "Adam: Epoch 90 Error=0.00016\n",
      "Adam: Epoch 100 Error=0.00147\n",
      "adam: Minimum of parabola is at 5. Value found is [5.03900403]\n"
     ]
    }
   ],
   "source": [
    "test_optimizers()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## NeuralNetwork class"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we can implement the `NeuralNetwork` class that calls the above `Optimizers` functions to update the weights.\n",
    "\n",
    "You must first complete the `use` function.  You can make use of the `forward_pass` function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "class NeuralNetwork():\n",
    "\n",
    "\n",
    "    def __init__(self, n_inputs, n_hiddens_per_layer, n_outputs):\n",
    "        self.n_inputs = n_inputs\n",
    "        self.n_outputs = n_outputs\n",
    "\n",
    "        # Set self.n_hiddens_per_layer to [] if argument is 0, [], or [0]\n",
    "        if n_hiddens_per_layer == 0 or n_hiddens_per_layer == [] or n_hiddens_per_layer == [0]:\n",
    "            self.n_hiddens_per_layer = []\n",
    "        else:\n",
    "            self.n_hiddens_per_layer = n_hiddens_per_layer\n",
    "\n",
    "        # Initialize weights, by first building list of all weight matrix shapes.\n",
    "        n_in = n_inputs\n",
    "        shapes = []\n",
    "        for nh in self.n_hiddens_per_layer:\n",
    "            shapes.append((n_in + 1, nh))\n",
    "            n_in = nh\n",
    "        shapes.append((n_in + 1, n_outputs))\n",
    "\n",
    "        # self.all_weights:  vector of all weights\n",
    "        # self.Ws: list of weight matrices by layer\n",
    "        self.all_weights, self.Ws = self.make_weights_and_views(shapes)\n",
    "\n",
    "        # Define arrays to hold gradient values.\n",
    "        # One array for each W array with same shape.\n",
    "        self.all_gradients, self.dE_dWs = self.make_weights_and_views(shapes)\n",
    "\n",
    "        self.trained = False\n",
    "        self.total_epochs = 0\n",
    "        self.error_trace = []\n",
    "        self.Xmeans = None\n",
    "        self.Xstds = None\n",
    "        self.Tmeans = None\n",
    "        self.Tstds = None\n",
    "\n",
    "\n",
    "    def make_weights_and_views(self, shapes):\n",
    "        # vector of all weights built by horizontally stacking flatenned matrices\n",
    "        # for each layer initialized with uniformly-distributed values.\n",
    "        all_weights = np.hstack([np.random.uniform(size=shape).flat / np.sqrt(shape[0])\n",
    "                                 for shape in shapes])\n",
    "        # Build list of views by reshaping corresponding elements from vector of all weights\n",
    "        # into correct shape for each layer.\n",
    "        views = []\n",
    "        start = 0\n",
    "        for shape in shapes:\n",
    "            size =shape[0] * shape[1]\n",
    "            views.append(all_weights[start:start + size].reshape(shape))\n",
    "            start += size\n",
    "        return all_weights, views\n",
    "\n",
    "\n",
    "    # Return string that shows how the constructor was called\n",
    "    def __repr__(self):\n",
    "        return f'NeuralNetwork({self.n_inputs}, {self.n_hiddens_per_layer}, {self.n_outputs})'\n",
    "\n",
    "\n",
    "    # Return string that is more informative to the user about the state of this neural network.\n",
    "    def __str__(self):\n",
    "        if self.trained:\n",
    "            return self.__repr__() + f' trained for {self.total_epochs} epochs, final training error {self.error_trace[-1]}'\n",
    "\n",
    "\n",
    "    def train(self, X, T, n_epochs, learning_rate, method='sgd'):\n",
    "        '''\n",
    "train: \n",
    "  X: n_samples x n_inputs matrix of input samples, one per row\n",
    "  T: n_samples x n_outputs matrix of target output values, one sample per row\n",
    "  n_epochs: number of passes to take through all samples updating weights each pass\n",
    "  learning_rate: factor controlling the step size of each update\n",
    "  method: is either 'sgd' or 'adam'\n",
    "        '''\n",
    "\n",
    "        # Setup standardization parameters\n",
    "        if self.Xmeans is None:\n",
    "            self.Xmeans = X.mean(axis=0)\n",
    "            self.Xstds = X.std(axis=0)\n",
    "            self.Xstds[self.Xstds == 0] = 1  # So we don't divide by zero when standardizing\n",
    "            self.Tmeans = T.mean(axis=0)\n",
    "            self.Tstds = T.std(axis=0)\n",
    "            \n",
    "        # Standardize X and T\n",
    "        X = (X - self.Xmeans) / self.Xstds\n",
    "        T = (T - self.Tmeans) / self.Tstds\n",
    "\n",
    "        # Instantiate Optimizers object by giving it vector of all weights\n",
    "        optimizer = Optimizers(self.all_weights)\n",
    "\n",
    "        # Define function to convert value from error_f into error in original T units.\n",
    "        error_convert_f = lambda err: (np.sqrt(err) * self.Tstds)[0] # to scalar\n",
    "\n",
    "        if method == 'sgd':\n",
    "\n",
    "            error_trace = optimizer.sgd(self.error_f, self.gradient_f,\n",
    "                                        fargs=[X, T], n_epochs=n_epochs,\n",
    "                                        learning_rate=learning_rate,\n",
    "                                        error_convert_f=error_convert_f)\n",
    "\n",
    "        elif method == 'adam':\n",
    "\n",
    "            error_trace = optimizer.adam(self.error_f, self.gradient_f,\n",
    "                                         fargs=[X, T], n_epochs=n_epochs,\n",
    "                                         learning_rate=learning_rate,\n",
    "                                         error_convert_f=error_convert_f)\n",
    "\n",
    "        else:\n",
    "            raise Exception(\"method must be 'sgd' or 'adam'\")\n",
    "        \n",
    "        self.error_trace = error_trace\n",
    "\n",
    "        # Return neural network object to allow applying other methods after training.\n",
    "        #  Example:    Y = nnet.train(X, T, 100, 0.01).use(X)\n",
    "        return self\n",
    "\n",
    "   \n",
    "    def forward_pass(self, X):\n",
    "        '''X assumed already standardized. Output returned as standardized.'''\n",
    "        self.Ys = [X]\n",
    "        for W in self.Ws[:-1]:\n",
    "            self.Ys.append(np.tanh(self.Ys[-1] @ W[1:, :] + W[0:1, :]))\n",
    "        last_W = self.Ws[-1]\n",
    "        self.Ys.append(self.Ys[-1] @ last_W[1:, :] + last_W[0:1, :])\n",
    "        return self.Ys\n",
    "\n",
    "    # Function to be minimized by optimizer method, mean squared error\n",
    "    def error_f(self, X, T):\n",
    "        Ys = self.forward_pass(X)\n",
    "        mean_sq_error = np.mean((T - Ys[-1]) ** 2)\n",
    "        return mean_sq_error\n",
    "\n",
    "    # Gradient of function to be minimized for use by optimizer method\n",
    "    def gradient_f(self, X, T):\n",
    "        '''Assumes forward_pass just called with layer outputs in self.Ys.'''\n",
    "        error = T - self.Ys[-1]\n",
    "        n_samples = X.shape[0]\n",
    "        n_outputs = T.shape[1]\n",
    "        delta = - error / (n_samples * n_outputs)\n",
    "        n_layers = len(self.n_hiddens_per_layer) + 1\n",
    "        # Step backwards through the layers to back-propagate the error (delta)\n",
    "        for layeri in range(n_layers - 1, -1, -1):\n",
    "            # gradient of all but bias weights\n",
    "            self.dE_dWs[layeri][1:, :] = self.Ys[layeri].T @ delta\n",
    "            # gradient of just the bias weights\n",
    "            self.dE_dWs[layeri][0:1, :] = np.sum(delta, 0)\n",
    "            # Back-propagate this layer's delta to previous layer\n",
    "            delta = delta @ self.Ws[layeri][1:, :].T * (1 - self.Ys[layeri] ** 2)\n",
    "        return self.all_gradients\n",
    "\n",
    "    def use(self, X):\n",
    "        '''X assumed to not be standardized. Return the unstandardized prediction'''\n",
    "        # Standardize X using Xmeans and Xstds in model\n",
    "        X = (X - self.Xmeans) / self.Xstds\n",
    "        \n",
    "        '''\n",
    "        #print(len(self.all_weights), len(X), len(self.Ws))\n",
    "        # Predict output values using weights in model\n",
    "        #X = np.insert(X,0,1,axis=1)\n",
    "        # predict = X1 @ model['w']\n",
    "        #predict = X @ self.Ws\n",
    "        # Unstandardize the predicted output values using Tmeans and Tstds in model\n",
    "        #Y = predict * self.Tstds + self.Tmeans\n",
    "        # Return the unstandardized output values\n",
    "        #return Y\n",
    "        '''\n",
    "        Y = self.forward_pass(X)\n",
    "        T = Y[-1] * self.Tstds + self.Tmeans\n",
    "\n",
    "        # Y[1:]\n",
    "        return T\n",
    "        "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Then test it with the `test_neuralnetwork` function.  Your results should be the same as those shown, because the pseudo-random number generator used to initialize the weights is set to start with the same seed."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-0.02509198,  0.09014286],\n",
       "       [ 0.04639879,  0.0197317 ]])"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.seed(42)\n",
    "np.random.uniform(-0.1, 0.1, size=(2, 2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-0.06879627, -0.0688011 ],\n",
       "       [-0.08838328,  0.07323523]])"
      ]
     },
     "execution_count": 7,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.uniform(-0.1, 0.1, size=(2, 2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-0.02509198,  0.09014286],\n",
       "       [ 0.04639879,  0.0197317 ]])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.seed(42)\n",
    "np.random.uniform(-0.1, 0.1, size=(2, 2))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "def test_neuralnetwork():\n",
    "    \n",
    "    np.random.seed(42)\n",
    "    \n",
    "    X = np.arange(100).reshape((-1, 1))\n",
    "    T = np.sin(X * 0.04)\n",
    "\n",
    "    n_hiddens = [10, 10]\n",
    "    n_epochs = 2000\n",
    "    learning_rate = 0.01\n",
    "    \n",
    "    nnetsgd = NeuralNetwork(1, n_hiddens, 1)\n",
    "    nnetsgd.train(X, T, n_epochs, learning_rate, method='sgd')\n",
    "\n",
    "    print()  # skip a line\n",
    "    \n",
    "    nnetadam = NeuralNetwork(1, n_hiddens, 1)\n",
    "    nnetadam.train(X, T, n_epochs, learning_rate, method='adam')\n",
    "\n",
    "    Ysgd = nnetsgd.use(X)\n",
    "    Yadam = nnetadam.use(X)\n",
    "\n",
    "    plt.figure(figsize=(15,10))\n",
    "    plt.subplot(1, 3, 1)\n",
    "    plt.plot(nnetsgd.error_trace, label='SGD')\n",
    "    plt.plot(nnetadam.error_trace, label='Adam')\n",
    "    plt.xlabel('Epoch')\n",
    "    plt.ylabel('RMSE')\n",
    "    plt.legend()\n",
    "    \n",
    "    plt.subplot(1, 3, 2)\n",
    "    plt.plot(T, Ysgd, 'o', label='SGD')\n",
    "    plt.plot(T, Yadam, 'o', label='Adam')\n",
    "    a = min(np.min(T), np.min(Ysgd))\n",
    "    b = max(np.max(T), np.max(Ysgd))\n",
    "    plt.plot([a, b], [a, b], 'k-', lw=3, alpha=0.5, label='45 degree')\n",
    "    plt.xlabel('Target')\n",
    "    plt.ylabel('Predicted')\n",
    "    plt.legend()\n",
    "\n",
    "    plt.subplot(1, 3, 3)\n",
    "    plt.plot(Ysgd, 'o-', label='SGD')\n",
    "    plt.plot(Yadam, 'o-', label='Adam')\n",
    "    plt.plot(T, label='Target')\n",
    "    plt.xlabel('Sample')\n",
    "    plt.ylabel('Target or Predicted')\n",
    "    plt.legend()\n",
    "\n",
    "    plt.tight_layout()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "sgd: Epoch 200 Error=0.49330\n",
      "sgd: Epoch 400 Error=0.46833\n",
      "sgd: Epoch 600 Error=0.44525\n",
      "sgd: Epoch 800 Error=0.42264\n",
      "sgd: Epoch 1000 Error=0.39428\n",
      "sgd: Epoch 1200 Error=0.35526\n",
      "sgd: Epoch 1400 Error=0.30300\n",
      "sgd: Epoch 1600 Error=0.24079\n",
      "sgd: Epoch 1800 Error=0.18020\n",
      "sgd: Epoch 2000 Error=0.13423\n",
      "\n",
      "Adam: Epoch 200 Error=0.11620\n",
      "Adam: Epoch 400 Error=0.00795\n",
      "Adam: Epoch 600 Error=0.00362\n",
      "Adam: Epoch 800 Error=0.00268\n",
      "Adam: Epoch 1000 Error=0.00236\n",
      "Adam: Epoch 1200 Error=0.00213\n",
      "Adam: Epoch 1400 Error=0.00200\n",
      "Adam: Epoch 1600 Error=0.00183\n",
      "Adam: Epoch 1800 Error=0.00771\n",
      "Adam: Epoch 2000 Error=0.00162\n"
     ]
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAABDAAAALICAYAAACJhQBYAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4yLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy+WH4yJAAAgAElEQVR4nOzde3xU1b338c+ayW1yIQmEa4JHahUViIkCgmBVULEXrbVHUdta7VFrT9VWe6horSKtRyq1HrUXy2k9nj710ebxgmi12MZaW4oKCAa84F2TAAKBhCQzk8xlPX/smdxIIAmZZCb7+369fGHW3tmshJWdtX97rd/PWGsREREREREREUlmnqHugIiIiIiIiIjIwSiAISIiIiIiIiJJTwEMEREREREREUl6CmCIiIiIiIiISNJTAENEREREREREkl7aUHegr4qKiuzhhx8+1N0QEenRhg0bdltrRw91P4aK7tMikszcfo8G3adFJLkd6D6dcgGMww8/nPXr1w91N0REemSM+Wio+zCUdJ8WkWTm9ns06D4tIsntQPdpbSERERERERERkaSnAIaIiIiIiIiIJD0FMEREREREREQk6aVcDgwRSR6hUIiamhqCweBQd2VIZGVlUVJSQnp6+lB3Jem5fawkisagiIhI6tG8yNGfeYwCGCLSbzU1NeTl5XH44YdjjBnq7gwqay11dXXU1NQwadKkoe5O0nPzWEkUjUEREZHUpHlR/+cx2kIiIv0WDAYZNWqUK2+8xhhGjRrl+sh5b7l5rCSKxqCIiEhq0ryo//MYBTBE5JC4/cYrvafv18DT91RERCQ16Xd4/74HCmCIiIiIiIiISNJTAENEUtrtt9/OlClTKC0tpaysjJdffplwOMxNN93EkUceSVlZGWVlZdx+++1tn+P1eikrK2PKlCkcd9xx/OxnPyMajQ7hVyGDQWNFREREpF0qzo2UxFNEUtbatWt5+umnefXVV8nMzGT37t20trZy8803s2PHDjZv3kxWVhaNjY3cddddbZ/n8/nYtGkTADt37uTiiy+moaGB2267bai+FOli5cZalq/eyrb6ABMKfCxaMJlzy4v7fT2NFREREUlVAz0vgtSdGymAISIpa/v27RQVFZGZmQlAUVERfr+f//7v/+bDDz8kKysLgLy8PJYsWdLtNcaMGcOK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\n",
      "text/plain": [
       "<Figure size 1080x720 with 3 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "test_neuralnetwork()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## ReLU Activation Function"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "class NeuralNetwork():\n",
    "\n",
    "\n",
    "    def __init__(self, n_inputs, n_hiddens_per_layer, n_outputs, activation_function=\"tanh\"):\n",
    "        self.n_inputs = n_inputs\n",
    "        self.n_outputs = n_outputs\n",
    "\n",
    "        # Set self.n_hiddens_per_layer to [] if argument is 0, [], or [0]\n",
    "        if n_hiddens_per_layer == 0 or n_hiddens_per_layer == [] or n_hiddens_per_layer == [0]:\n",
    "            self.n_hiddens_per_layer = []\n",
    "        else:\n",
    "            self.n_hiddens_per_layer = n_hiddens_per_layer\n",
    "\n",
    "        # Initialize weights, by first building list of all weight matrix shapes.\n",
    "        n_in = n_inputs\n",
    "        shapes = []\n",
    "        for nh in self.n_hiddens_per_layer:\n",
    "            shapes.append((n_in + 1, nh))\n",
    "            n_in = nh\n",
    "        shapes.append((n_in + 1, n_outputs))\n",
    "\n",
    "        # self.all_weights:  vector of all weights\n",
    "        # self.Ws: list of weight matrices by layer\n",
    "        self.all_weights, self.Ws = self.make_weights_and_views(shapes)\n",
    "\n",
    "        # Define arrays to hold gradient values.\n",
    "        # One array for each W array with same shape.\n",
    "        self.all_gradients, self.dE_dWs = self.make_weights_and_views(shapes)\n",
    "\n",
    "        self.trained = False\n",
    "        self.total_epochs = 0\n",
    "        self.error_trace = []\n",
    "        self.Xmeans = None\n",
    "        self.Xstds = None\n",
    "        self.Tmeans = None\n",
    "        self.Tstds = None\n",
    "        self.activation_function = activation_function\n",
    "        \n",
    "    def relu(s):\n",
    "        return np.maximum(0, s)\n",
    "        \n",
    "        \n",
    "    def grad_relu(s):\n",
    "        return np.heaviside(s, 1)\n",
    "\n",
    "\n",
    "    def make_weights_and_views(self, shapes):\n",
    "        # vector of all weights built by horizontally stacking flatenned matrices\n",
    "        # for each layer initialized with uniformly-distributed values.\n",
    "        all_weights = np.hstack([np.random.uniform(size=shape).flat / np.sqrt(shape[0])\n",
    "                                 for shape in shapes])\n",
    "        # Build list of views by reshaping corresponding elements from vector of all weights\n",
    "        # into correct shape for each layer.\n",
    "        views = []\n",
    "        start = 0\n",
    "        for shape in shapes:\n",
    "            size =shape[0] * shape[1]\n",
    "            views.append(all_weights[start:start + size].reshape(shape))\n",
    "            start += size\n",
    "        return all_weights, views\n",
    "\n",
    "\n",
    "    # Return string that shows how the constructor was called\n",
    "    def __repr__(self):\n",
    "        return f'NeuralNetwork({self.n_inputs}, {self.n_hiddens_per_layer}, {self.n_outputs})'\n",
    "\n",
    "\n",
    "    # Return string that is more informative to the user about the state of this neural network.\n",
    "    def __str__(self):\n",
    "        if self.trained:\n",
    "            return self.__repr__() + f' trained for {self.total_epochs} epochs, final training error {self.error_trace[-1]}'\n",
    "\n",
    "\n",
    "    def train(self, X, T, n_epochs, learning_rate, method='sgd'):\n",
    "\n",
    "        # Setup standardization parameters\n",
    "        if self.Xmeans is None:\n",
    "            self.Xmeans = X.mean(axis=0)\n",
    "            self.Xstds = X.std(axis=0)\n",
    "            self.Xstds[self.Xstds == 0] = 1  # So we don't divide by zero when standardizing\n",
    "            self.Tmeans = T.mean(axis=0)\n",
    "            self.Tstds = T.std(axis=0)\n",
    "            \n",
    "        # Standardize X and T\n",
    "        X = (X - self.Xmeans) / self.Xstds\n",
    "        T = (T - self.Tmeans) / self.Tstds\n",
    "\n",
    "        # Instantiate Optimizers object by giving it vector of all weights\n",
    "        optimizer = Optimizers(self.all_weights)\n",
    "\n",
    "        # Define function to convert value from error_f into error in original T units.\n",
    "        error_convert_f = lambda err: (np.sqrt(err) * self.Tstds)[0] # to scalar\n",
    "\n",
    "        if method == 'sgd':\n",
    "\n",
    "            error_trace = optimizer.sgd(self.error_f, self.gradient_f,\n",
    "                                        fargs=[X, T], n_epochs=n_epochs,\n",
    "                                        learning_rate=learning_rate,\n",
    "                                        error_convert_f=error_convert_f)\n",
    "\n",
    "        elif method == 'adam':\n",
    "\n",
    "            error_trace = optimizer.adam(self.error_f, self.gradient_f,\n",
    "                                         fargs=[X, T], n_epochs=n_epochs,\n",
    "                                         learning_rate=learning_rate,\n",
    "                                         error_convert_f=error_convert_f)\n",
    "\n",
    "        else:\n",
    "            raise Exception(\"method must be 'sgd' or 'adam'\")\n",
    "        \n",
    "        self.error_trace = error_trace\n",
    "\n",
    "        # Return neural network object to allow applying other methods after training.\n",
    "        #  Example:    Y = nnet.train(X, T, 100, 0.01).use(X)\n",
    "        return self\n",
    "\n",
    "   \n",
    "    def forward_pass(self, X):\n",
    "        '''X assumed already standardized. Output returned as standardized.'''\n",
    "        self.Ys = [X]\n",
    "        for W in self.Ws[:-1]:\n",
    "            \n",
    "            if self.activation_function == 'tanh':\n",
    "                self.Ys.append(np.tanh(self.Ys[-1] @ W[1:, :] + W[0:1, :]))\n",
    "                \n",
    "            if self.activation_function == 'relu':\n",
    "                self.Ys.append(self.relu(self.Ys[-1] @ W[1:, :] + W[0:1, :]))\n",
    "                \n",
    "        last_W = self.Ws[-1]\n",
    "        self.Ys.append(self.Ys[-1] @ last_W[1:, :] + last_W[0:1, :])\n",
    "        return self.Ys\n",
    "\n",
    "    # Function to be minimized by optimizer method, mean squared error\n",
    "    def error_f(self, X, T):\n",
    "        Ys = self.forward_pass(X)\n",
    "        mean_sq_error = np.mean((T - Ys[-1]) ** 2)\n",
    "        return mean_sq_error\n",
    "\n",
    "    # Gradient of function to be minimized for use by optimizer method\n",
    "    def gradient_f(self, X, T):\n",
    "        '''Assumes forward_pass just called with layer outputs in self.Ys.'''\n",
    "        error = T - self.Ys[-1]\n",
    "        n_samples = X.shape[0]\n",
    "        n_outputs = T.shape[1]\n",
    "        delta = - error / (n_samples * n_outputs)\n",
    "        n_layers = len(self.n_hiddens_per_layer) + 1\n",
    "        # Step backwards through the layers to back-propagate the error (delta)\n",
    "        for layeri in range(n_layers - 1, -1, -1):\n",
    "            # gradient of all but bias weights\n",
    "            self.dE_dWs[layeri][1:, :] = self.Ys[layeri].T @ delta\n",
    "            # gradient of just the bias weights\n",
    "            self.dE_dWs[layeri][0:1, :] = np.sum(delta, 0)\n",
    "            # Back-propagate this layer's delta to previous layer\n",
    "            delta = delta @ self.Ws[layeri][1:, :].T * (1 - self.Ys[layeri] ** 2)\n",
    "            \n",
    "        if self.activation_function == 'tanh':\n",
    "            np.tanh(self.all_gradients)\n",
    "            \n",
    "        if self.activation_function == 'relu':\n",
    "            self.grad_relu(self.all_gradients)\n",
    "        \n",
    "        return self.all_gradients\n",
    "\n",
    "    def use(self, X):\n",
    "        X = (X - self.Xmeans) / self.Xstds\n",
    "        Y = self.forward_pass(X)\n",
    "        T = Y[-1] * self.Tstds + self.Tmeans\n",
    "        return T"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Now for the Experiments!"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now that your code is working, let's apply it to some interesting data.\n",
    "\n",
    "Read in the `auto-mpg.data` that we have used in lectures.  Let's apply neural networks to predict `mpg` using various neural network architectures, numbers of epochs, and our two activation functions.\n",
    "\n",
    "This time we will partition the data into five parts after randomly rearranging the samples.  We will assign the first partition as the validation set, the second one as the test set, and the remaining parts will be vertically stacked to form the training set, as discussed in lecture.  We can use the RMSE on the validation set to pick the best values of the number of epochs and the network architecture.  Then to report on the RMSE we expect on new data, we will report the test set RMSE."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Read in the `auto-mpg.data` using `pandas` and remove all samples that contain missing values.  You should end up with 392 samples.\n",
    "\n",
    "Now randomly reorder the samples.  First run `np.random.seed(42)` to guarantee that we all use the same random ordering of samples.\n",
    "\n",
    "Partition the data into five folds, as shown in lecture.  To do this, complete the following function."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import numpy as np\n",
    "\n",
    "'''    \n",
    "    1. mpg:           continuous\n",
    "    2. cylinders:     multi-valued discrete\n",
    "    3. displacement:  continuous\n",
    "    4. horsepower:    continuous\n",
    "    5. weight:        continuous\n",
    "    6. acceleration:  continuous\n",
    "    7. model year:    multi-valued discrete\n",
    "    8. origin:        multi-valued discrete\n",
    "    9. car name:      string (unique for each instance)\n",
    "'''\n",
    "\n",
    "\n",
    "def partition(X, T, n_folds, random_shuffle=True):\n",
    "    rows = np.arange(X.shape[0])\n",
    "    \n",
    "    if random_shuffle:\n",
    "        np.random.seed(42)\n",
    "        np.random.shuffle(rows)\n",
    "    \n",
    "    X = X[rows, :]\n",
    "    T = T[rows, :]\n",
    "    n_samples = X.shape[0]\n",
    "    n_per_fold = n_samples // n_folds # double-slash = \"floor division\" which rounds down to the nearest number\n",
    "    n_last_fold = n_samples - n_per_fold * (n_folds - 1)  # handles case when n_samples not evenly divided by n_folds\n",
    "\n",
    "    folds = []\n",
    "    start = 0\n",
    "    for foldi in range(n_folds-1):\n",
    "        folds.append( (X[start:start + n_per_fold, :], T[start:start + n_per_fold, :]) )\n",
    "        start += n_per_fold\n",
    "    folds.append( (X[start:, :], T[start:, :]) )   # Changed in notes 07.2\n",
    "\n",
    "\n",
    "    Xvalidate, Tvalidate = folds[0]\n",
    "    Xtest, Ttest = folds[1]\n",
    "    Xtrain, Ttrain = np.vstack([X for (X, _) in folds[2:]]), np.vstack([T for (_, T) in folds[2:]]) # what is this doing? Hint: look at [2:]\n",
    "    \n",
    "    return Xtrain, Ttrain, Xvalidate, Tvalidate, Xtest, Ttest\n",
    "\n",
    "#df = df.sample(frac=1, replace=True, random_state=np.random.seed(42))\n",
    "df = pd.read_csv('auto-mpg.data-original', delim_whitespace=True, na_values=\"NA\", header=None)\n",
    "df = df.dropna()\n",
    "\n",
    "data = df.iloc[:, :-1].values # view everything except the car names (last column)\n",
    "T = data[:, 0:1]  # data[:,0] results in a one-dimensional matrix, data[:,0:1] preserves its two-dimensional nature.\n",
    "X = data[:, 1:] # give me the input variables\n",
    "\n",
    "partition(X, T, 5)\n",
    "\n",
    "names =  ['mpg','cylinders','displacement','horsepower','weight','acceleration','year','origin', 'model']\n",
    "df.columns = names\n",
    "Xnames = names[1:]\n",
    "Tname = names[0]\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Write a function named `run_experiment` that uses three nested for loops to try different values of the parameters `n_epochs`, `n_hidden_units_per_layer` and `activation_function` which will just be either `tanh` or `relu`. Don't forget to try `[0]` for one of the values of `n_hidden_units_per_layer` to include a linear model in your tests.  For each set of parameter values, create and train a neural network using the 'adam' optimization method and use the neural network on the training, validation and test sets.  Collect the parameter values and the RMSE for the training, validation, and test set in a list.  When your loops are done, construct a `pandas.DataFrame` from the list of results, for easy printing.  The first five lines might look like:\n",
    "\n",
    "```\n",
    "   epochs        nh    lr act func  RMSE Train  RMSE Val  RMSE Test\n",
    "0    1000       [0]  0.01     tanh    3.356401  3.418705   3.116480\n",
    "1    1000       [0]  0.01     relu    3.354528  3.428324   3.125064\n",
    "2    1000      [20]  0.01     tanh    1.992509  2.355746   2.459506\n",
    "3    1000      [20]  0.01     relu    2.448536  2.026954   2.581707\n",
    "4    1000  [20, 20]  0.01     tanh    1.518916  2.468188   3.118376\n",
    "```\n",
    "Your function must return a `pandas.DataFrame` like this one.\n",
    "\n",
    "Before starting the nested for loops, your `run_experiment` function must first call your `partition` function to form the training, validation and test sets."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "An example call of your function would look like this:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "(236, 7) (236, 1) (78, 7) (78, 1) (78, 7) (78, 1)\n",
      "Adam: Epoch 100 Error=3.78158\n",
      "Adam: Epoch 200 Error=3.54286\n",
      "Adam: Epoch 300 Error=3.47537\n",
      "Adam: Epoch 400 Error=3.43532\n",
      "Adam: Epoch 500 Error=3.41365\n",
      "Adam: Epoch 600 Error=3.40252\n",
      "Adam: Epoch 700 Error=3.39700\n",
      "Adam: Epoch 800 Error=3.39434\n",
      "Adam: Epoch 900 Error=3.39309\n",
      "Adam: Epoch 1000 Error=3.39250\n",
      "Adam: Epoch 100 Error=3.67969\n",
      "Adam: Epoch 200 Error=3.53033\n",
      "Adam: Epoch 300 Error=3.45684\n",
      "Adam: Epoch 400 Error=3.42258\n",
      "Adam: Epoch 500 Error=3.40645\n",
      "Adam: Epoch 600 Error=3.39870\n",
      "Adam: Epoch 700 Error=3.39500\n",
      "Adam: Epoch 800 Error=3.39327\n",
      "Adam: Epoch 900 Error=3.39250\n",
      "Adam: Epoch 1000 Error=3.39217\n",
      "Adam: Epoch 100 Error=3.08583\n",
      "Adam: Epoch 200 Error=2.72878\n",
      "Adam: Epoch 300 Error=2.61373\n",
      "Adam: Epoch 400 Error=2.52514\n",
      "Adam: Epoch 500 Error=2.43382\n",
      "Adam: Epoch 600 Error=2.31638\n",
      "Adam: Epoch 700 Error=2.21586\n",
      "Adam: Epoch 800 Error=2.14737\n",
      "Adam: Epoch 900 Error=2.08554\n",
      "Adam: Epoch 1000 Error=2.02402\n",
      "Adam: Epoch 100 Error=4.13949\n",
      "Adam: Epoch 200 Error=4.43232\n",
      "Adam: Epoch 300 Error=3.64511\n",
      "Adam: Epoch 400 Error=4.85588\n",
      "Adam: Epoch 500 Error=4.79406\n",
      "Adam: Epoch 600 Error=4.51883\n",
      "Adam: Epoch 700 Error=4.55433\n",
      "Adam: Epoch 800 Error=5.37580\n",
      "Adam: Epoch 900 Error=4.54167\n",
      "Adam: Epoch 1000 Error=5.00443\n",
      "Adam: Epoch 100 Error=2.77949\n",
      "Adam: Epoch 200 Error=2.11108\n",
      "Adam: Epoch 300 Error=1.76224\n",
      "Adam: Epoch 400 Error=1.46153\n",
      "Adam: Epoch 500 Error=1.25730\n",
      "Adam: Epoch 600 Error=1.10091\n",
      "Adam: Epoch 700 Error=0.97504\n",
      "Adam: Epoch 800 Error=0.84749\n",
      "Adam: Epoch 900 Error=0.69862\n",
      "Adam: Epoch 1000 Error=0.59442\n",
      "Adam: Epoch 100 Error=7.13997\n",
      "Adam: Epoch 200 Error=14.63490\n",
      "Adam: Epoch 300 Error=4.18579\n",
      "Adam: Epoch 400 Error=11.88108\n",
      "Adam: Epoch 500 Error=5.17633\n",
      "Adam: Epoch 600 Error=5.76742\n",
      "Adam: Epoch 700 Error=3.91746\n",
      "Adam: Epoch 800 Error=4.40690\n",
      "Adam: Epoch 900 Error=4.91841\n",
      "Adam: Epoch 1000 Error=4.11937\n",
      "Adam: Epoch 200 Error=3.53889\n",
      "Adam: Epoch 400 Error=3.42736\n",
      "Adam: Epoch 600 Error=3.39955\n",
      "Adam: Epoch 800 Error=3.39335\n",
      "Adam: Epoch 1000 Error=3.39216\n",
      "Adam: Epoch 1200 Error=3.39198\n",
      "Adam: Epoch 1400 Error=3.39196\n",
      "Adam: Epoch 1600 Error=3.39196\n",
      "Adam: Epoch 1800 Error=3.39196\n",
      "Adam: Epoch 2000 Error=3.39196\n",
      "Adam: Epoch 200 Error=3.52839\n",
      "Adam: Epoch 400 Error=3.43475\n",
      "Adam: Epoch 600 Error=3.40653\n",
      "Adam: Epoch 800 Error=3.39713\n",
      "Adam: Epoch 1000 Error=3.39364\n",
      "Adam: Epoch 1200 Error=3.39243\n",
      "Adam: Epoch 1400 Error=3.39207\n",
      "Adam: Epoch 1600 Error=3.39198\n",
      "Adam: Epoch 1800 Error=3.39197\n",
      "Adam: Epoch 2000 Error=3.39196\n",
      "Adam: Epoch 200 Error=2.76126\n",
      "Adam: Epoch 400 Error=2.46254\n",
      "Adam: Epoch 600 Error=2.18558\n",
      "Adam: Epoch 800 Error=2.04329\n",
      "Adam: Epoch 1000 Error=1.96100\n",
      "Adam: Epoch 1200 Error=1.90298\n",
      "Adam: Epoch 1400 Error=1.83695\n",
      "Adam: Epoch 1600 Error=1.76299\n",
      "Adam: Epoch 1800 Error=1.72134\n",
      "Adam: Epoch 2000 Error=1.67990\n",
      "Adam: Epoch 200 Error=3.49393\n",
      "Adam: Epoch 400 Error=3.96623\n",
      "Adam: Epoch 600 Error=4.86596\n",
      "Adam: Epoch 800 Error=5.25320\n",
      "Adam: Epoch 1000 Error=4.24819\n",
      "Adam: Epoch 1200 Error=4.79590\n",
      "Adam: Epoch 1400 Error=5.07634\n",
      "Adam: Epoch 1600 Error=5.16489\n",
      "Adam: Epoch 1800 Error=5.14035\n",
      "Adam: Epoch 2000 Error=5.04855\n",
      "Adam: Epoch 200 Error=1.97852\n",
      "Adam: Epoch 400 Error=1.38332\n",
      "Adam: Epoch 600 Error=1.06088\n",
      "Adam: Epoch 800 Error=0.76713\n",
      "Adam: Epoch 1000 Error=0.61765\n",
      "Adam: Epoch 1200 Error=0.52043\n",
      "Adam: Epoch 1400 Error=0.47815\n",
      "Adam: Epoch 1600 Error=0.39585\n",
      "Adam: Epoch 1800 Error=0.34875\n",
      "Adam: Epoch 2000 Error=0.30778\n",
      "Adam: Epoch 200 Error=4.26692\n",
      "Adam: Epoch 400 Error=3.13022\n",
      "Adam: Epoch 600 Error=4.56205\n",
      "Adam: Epoch 800 Error=3.86776\n",
      "Adam: Epoch 1000 Error=14.44801\n",
      "Adam: Epoch 1200 Error=4.47265\n",
      "Adam: Epoch 1400 Error=3.83574\n",
      "Adam: Epoch 1600 Error=3.54805\n",
      "Adam: Epoch 1800 Error=7.37013\n",
      "Adam: Epoch 2000 Error=3.37071\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>epochs</th>\n",
       "      <th>nh</th>\n",
       "      <th>lr</th>\n",
       "      <th>act func</th>\n",
       "      <th>RMSE Train</th>\n",
       "      <th>RMSE Val</th>\n",
       "      <th>RMSE Test</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1000</td>\n",
       "      <td>[0]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>tanh</td>\n",
       "      <td>3.392493</td>\n",
       "      <td>3.342197</td>\n",
       "      <td>3.139467</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>1000</td>\n",
       "      <td>[0]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>relu</td>\n",
       "      <td>3.392163</td>\n",
       "      <td>3.335800</td>\n",
       "      <td>3.138626</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>1000</td>\n",
       "      <td>[10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>tanh</td>\n",
       "      <td>2.023484</td>\n",
       "      <td>2.529690</td>\n",
       "      <td>3.012040</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>1000</td>\n",
       "      <td>[10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>relu</td>\n",
       "      <td>5.004523</td>\n",
       "      <td>4.611447</td>\n",
       "      <td>4.732527</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>1000</td>\n",
       "      <td>[100, 10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>tanh</td>\n",
       "      <td>0.572793</td>\n",
       "      <td>3.457299</td>\n",
       "      <td>3.371508</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>5</th>\n",
       "      <td>1000</td>\n",
       "      <td>[100, 10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>relu</td>\n",
       "      <td>4.165823</td>\n",
       "      <td>4.232261</td>\n",
       "      <td>4.773075</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>6</th>\n",
       "      <td>2000</td>\n",
       "      <td>[0]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>tanh</td>\n",
       "      <td>3.391963</td>\n",
       "      <td>3.327554</td>\n",
       "      <td>3.138830</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>7</th>\n",
       "      <td>2000</td>\n",
       "      <td>[0]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>relu</td>\n",
       "      <td>3.391964</td>\n",
       "      <td>3.327876</td>\n",
       "      <td>3.138808</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>8</th>\n",
       "      <td>2000</td>\n",
       "      <td>[10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>tanh</td>\n",
       "      <td>1.679677</td>\n",
       "      <td>3.191609</td>\n",
       "      <td>3.329430</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>9</th>\n",
       "      <td>2000</td>\n",
       "      <td>[10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>relu</td>\n",
       "      <td>5.048264</td>\n",
       "      <td>4.729531</td>\n",
       "      <td>5.049052</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>10</th>\n",
       "      <td>2000</td>\n",
       "      <td>[100, 10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>tanh</td>\n",
       "      <td>0.307531</td>\n",
       "      <td>3.297128</td>\n",
       "      <td>3.862628</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>11</th>\n",
       "      <td>2000</td>\n",
       "      <td>[100, 10]</td>\n",
       "      <td>0.01</td>\n",
       "      <td>relu</td>\n",
       "      <td>3.371412</td>\n",
       "      <td>3.276538</td>\n",
       "      <td>3.208718</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "    epochs         nh    lr act func  RMSE Train  RMSE Val  RMSE Test\n",
       "0     1000        [0]  0.01     tanh    3.392493  3.342197   3.139467\n",
       "1     1000        [0]  0.01     relu    3.392163  3.335800   3.138626\n",
       "2     1000       [10]  0.01     tanh    2.023484  2.529690   3.012040\n",
       "3     1000       [10]  0.01     relu    5.004523  4.611447   4.732527\n",
       "4     1000  [100, 10]  0.01     tanh    0.572793  3.457299   3.371508\n",
       "5     1000  [100, 10]  0.01     relu    4.165823  4.232261   4.773075\n",
       "6     2000        [0]  0.01     tanh    3.391963  3.327554   3.138830\n",
       "7     2000        [0]  0.01     relu    3.391964  3.327876   3.138808\n",
       "8     2000       [10]  0.01     tanh    1.679677  3.191609   3.329430\n",
       "9     2000       [10]  0.01     relu    5.048264  4.729531   5.049052\n",
       "10    2000  [100, 10]  0.01     tanh    0.307531  3.297128   3.862628\n",
       "11    2000  [100, 10]  0.01     relu    3.371412  3.276538   3.208718"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import pandas as pd\n",
    "\n",
    "class Optimizers():\n",
    "\n",
    "    def __init__(self, all_weights):\n",
    "        '''all_weights is a vector of all of a neural networks weights concatenated into a one-dimensional vector'''\n",
    "        \n",
    "        self.all_weights = all_weights\n",
    "\n",
    "        # The following initializations are only used by adam.\n",
    "        # Only initializing mt, vt, beta1t and beta2t here allows multiple calls to adam to handle training\n",
    "        # with multiple subsets (batches) of training data.\n",
    "        self.mt = np.zeros_like(all_weights)\n",
    "        self.vt = np.zeros_like(all_weights)\n",
    "        self.beta1 = 0.9\n",
    "        self.beta2 = 0.999\n",
    "        self.beta1t = 1  # was self.beta1\n",
    "        self.beta2t = 1  # was self.beta2\n",
    "\n",
    "        \n",
    "    def sgd(self, error_f, gradient_f, fargs=[], n_epochs=100, learning_rate=0.001, error_convert_f=None):\n",
    "        '''\n",
    "error_f: function that requires X and T as arguments (given in fargs) and returns mean squared error.\n",
    "gradient_f: function that requires X and T as arguments (in fargs) and returns gradient of mean squared error\n",
    "            with respect to each weight.\n",
    "error_convert_f: function that converts the standardized error from error_f to original T units.\n",
    "        '''\n",
    "\n",
    "        error_trace = []\n",
    "        epochs_per_print = n_epochs // 10\n",
    "\n",
    "        for epoch in range(n_epochs):\n",
    "\n",
    "            error = error_f(*fargs)\n",
    "            grad = gradient_f(*fargs)\n",
    "\n",
    "            # Update all weights using -= to modify their values in-place.\n",
    "            self.all_weights -= learning_rate * grad\n",
    "\n",
    "            if error_convert_f:\n",
    "                error = error_convert_f(error)\n",
    "            error_trace.append(error)\n",
    "\n",
    "            if (epoch + 1) % max(1, epochs_per_print) == 0:\n",
    "                print(f'sgd: Epoch {epoch+1:d} Error={error:.5f}')\n",
    "\n",
    "        return error_trace\n",
    "\n",
    "    def adam(self, error_f, gradient_f, fargs=[], n_epochs=100, learning_rate=0.001, error_convert_f=None):\n",
    "        '''\n",
    "error_f: function that requires X and T as arguments (given in fargs) and returns mean squared error.\n",
    "gradient_f: function that requires X and T as arguments (in fargs) and returns gradient of mean squared error\n",
    "            with respect to each weight.\n",
    "error_convert_f: function that converts the standardized error from error_f to original T units.\n",
    "        '''\n",
    "        \n",
    "        # adam = Adaptive Moment Estimation\n",
    "\n",
    "        alpha = learning_rate  # learning rate called alpha in original paper on adam\n",
    "        epsilon = 1e-8\n",
    "        error_trace = []\n",
    "        epochs_per_print = n_epochs // 10\n",
    "\n",
    "        for epoch in range(n_epochs):\n",
    "\n",
    "            error = error_f(*fargs)\n",
    "            grad = gradient_f(*fargs)\n",
    "\n",
    "            # Finish Adam implementation here by updating\n",
    "            #   self.mt\n",
    "            #   self.vt\n",
    "            #   self.beta1t\n",
    "            #   self.beta2t\n",
    "            # and updating values of self.all_weights\n",
    "            \n",
    "            # mt = beta1 * mt + (1 - beta1) * gradE_W\n",
    "            gradE_W = learning_rate * grad\n",
    "            self.mt = self.beta1 * self.mt + (1 - self.beta1) * (gradE_W)\n",
    "            \n",
    "            # vt = beta2 * vt + (1 - beta2) * np.square(gradE_W)\n",
    "            self.vt = self.beta2 * self.vt + (1 - self.beta2) * np.square(gradE_W)\n",
    "            \n",
    "            # beta1t *= beta1\n",
    "            self.beta1t *= self.beta1\n",
    "            \n",
    "            # beta2t *= beta2\n",
    "            self.beta2t *= self.beta2\n",
    "            \n",
    "            # mhat = mt / (1 - beta1)\n",
    "            mhat = self.mt / (1 - self.beta1t)\n",
    "            \n",
    "            # vhat = vt / (1 - beta2)\n",
    "            vhat = self.vt / (1 - self.beta2t)\n",
    "            \n",
    "            # w -= rho * mhat / (np.sqrt(vhat) + epsilon)\n",
    "            # rho = learning rate?\n",
    "            self.all_weights -= learning_rate * mhat / (np.sqrt(vhat) + epsilon)\n",
    "        \n",
    "\n",
    "            if error_convert_f:\n",
    "                error = error_convert_f(error)\n",
    "            error_trace.append(error)\n",
    "\n",
    "            if (epoch + 1) % max(1, epochs_per_print) == 0:\n",
    "                print(f'Adam: Epoch {epoch+1:d} Error={error:.5f}')\n",
    "\n",
    "        return error_trace\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "class NeuralNetwork():\n",
    "\n",
    "\n",
    "    def __init__(self, n_inputs, n_hiddens_per_layer, n_outputs, activation_function=\"tanh\"):\n",
    "        self.n_inputs = n_inputs\n",
    "        self.n_outputs = n_outputs\n",
    "\n",
    "        # Set self.n_hiddens_per_layer to [] if argument is 0, [], or [0]\n",
    "        if n_hiddens_per_layer == 0 or n_hiddens_per_layer == [] or n_hiddens_per_layer == [0]:\n",
    "            self.n_hiddens_per_layer = []\n",
    "        else:\n",
    "            self.n_hiddens_per_layer = n_hiddens_per_layer\n",
    "\n",
    "        # Initialize weights, by first building list of all weight matrix shapes.\n",
    "        n_in = n_inputs\n",
    "        shapes = []\n",
    "        for nh in self.n_hiddens_per_layer:\n",
    "            shapes.append((n_in + 1, nh))\n",
    "            n_in = nh\n",
    "        shapes.append((n_in + 1, n_outputs))\n",
    "\n",
    "        # self.all_weights:  vector of all weights\n",
    "        # self.Ws: list of weight matrices by layer\n",
    "        self.all_weights, self.Ws = self.make_weights_and_views(shapes)\n",
    "\n",
    "        # Define arrays to hold gradient values.\n",
    "        # One array for each W array with same shape.\n",
    "        self.all_gradients, self.dE_dWs = self.make_weights_and_views(shapes)\n",
    "\n",
    "        self.trained = False\n",
    "        self.total_epochs = 0\n",
    "        self.error_trace = []\n",
    "        self.Xmeans = None\n",
    "        self.Xstds = None\n",
    "        self.Tmeans = None\n",
    "        self.Tstds = None\n",
    "        self.activation_function = activation_function\n",
    "        \n",
    "    def relu(self,s):\n",
    "        return np.maximum(0, s)\n",
    "        \n",
    "        \n",
    "    def grad_relu(self,s):\n",
    "        return np.heaviside(s, 1)\n",
    "\n",
    "\n",
    "    def make_weights_and_views(self, shapes):\n",
    "        # vector of all weights built by horizontally stacking flatenned matrices\n",
    "        # for each layer initialized with uniformly-distributed values.\n",
    "        all_weights = np.hstack([np.random.uniform(size=shape).flat / np.sqrt(shape[0])\n",
    "                                 for shape in shapes])\n",
    "        # Build list of views by reshaping corresponding elements from vector of all weights\n",
    "        # into correct shape for each layer.\n",
    "        views = []\n",
    "        start = 0\n",
    "        for shape in shapes:\n",
    "            size =shape[0] * shape[1]\n",
    "            views.append(all_weights[start:start + size].reshape(shape))\n",
    "            start += size\n",
    "        return all_weights, views\n",
    "\n",
    "\n",
    "    # Return string that shows how the constructor was called\n",
    "    def __repr__(self):\n",
    "        return f'NeuralNetwork({self.n_inputs}, {self.n_hiddens_per_layer}, {self.n_outputs})'\n",
    "\n",
    "\n",
    "    # Return string that is more informative to the user about the state of this neural network.\n",
    "    def __str__(self):\n",
    "        if self.trained:\n",
    "            return self.__repr__() + f' trained for {self.total_epochs} epochs, final training error {self.error_trace[-1]}'\n",
    "\n",
    "\n",
    "    def train(self, X, T, n_epochs, learning_rate, method='sgd'):\n",
    "\n",
    "        # Setup standardization parameters\n",
    "        if self.Xmeans is None:\n",
    "            self.Xmeans = X.mean(axis=0)\n",
    "            self.Xstds = X.std(axis=0)\n",
    "            self.Xstds[self.Xstds == 0] = 1  # So we don't divide by zero when standardizing\n",
    "            self.Tmeans = T.mean(axis=0)\n",
    "            self.Tstds = T.std(axis=0)\n",
    "            \n",
    "        # Standardize X and T\n",
    "        X = (X - self.Xmeans) / self.Xstds\n",
    "        T = (T - self.Tmeans) / self.Tstds\n",
    "\n",
    "        # Instantiate Optimizers object by giving it vector of all weights\n",
    "        optimizer = Optimizers(self.all_weights)\n",
    "\n",
    "        # Define function to convert value from error_f into error in original T units.\n",
    "        error_convert_f = lambda err: (np.sqrt(err) * self.Tstds)[0] # to scalar\n",
    "\n",
    "        if method == 'sgd':\n",
    "\n",
    "            error_trace = optimizer.sgd(self.error_f, self.gradient_f,\n",
    "                                        fargs=[X, T], n_epochs=n_epochs,\n",
    "                                        learning_rate=learning_rate,\n",
    "                                        error_convert_f=error_convert_f)\n",
    "\n",
    "        elif method == 'adam':\n",
    "\n",
    "            error_trace = optimizer.adam(self.error_f, self.gradient_f,\n",
    "                                         fargs=[X, T], n_epochs=n_epochs,\n",
    "                                         learning_rate=learning_rate,\n",
    "                                         error_convert_f=error_convert_f)\n",
    "\n",
    "        else:\n",
    "            raise Exception(\"method must be 'sgd' or 'adam'\")\n",
    "        \n",
    "        self.error_trace = error_trace\n",
    "\n",
    "        # Return neural network object to allow applying other methods after training.\n",
    "        #  Example:    Y = nnet.train(X, T, 100, 0.01).use(X)\n",
    "        return self\n",
    "\n",
    "   \n",
    "    def forward_pass(self, X):\n",
    "        '''X assumed already standardized. Output returned as standardized.'''\n",
    "        self.Ys = [X]\n",
    "        for W in self.Ws[:-1]:\n",
    "            \n",
    "            \n",
    "            \n",
    "            \n",
    "            \n",
    "            if self.activation_function == 'tanh':\n",
    "                self.Ys.append(np.tanh(self.Ys[-1] @ W[1:, :] + W[0:1, :]))\n",
    "                \n",
    "            if self.activation_function == 'relu':\n",
    "                self.Ys.append(self.relu(self.Ys[-1] @ W[1:, :] + W[0:1, :]))\n",
    "                \n",
    "                \n",
    "                \n",
    "                \n",
    "                \n",
    "        last_W = self.Ws[-1]\n",
    "        self.Ys.append(self.Ys[-1] @ last_W[1:, :] + last_W[0:1, :])\n",
    "        return self.Ys\n",
    "\n",
    "    # Function to be minimized by optimizer method, mean squared error\n",
    "    def error_f(self, X, T):\n",
    "        Ys = self.forward_pass(X)\n",
    "        mean_sq_error = np.mean((T - Ys[-1]) ** 2)\n",
    "        return mean_sq_error\n",
    "\n",
    "    # Gradient of function to be minimized for use by optimizer method\n",
    "    def gradient_f(self, X, T):\n",
    "        '''Assumes forward_pass just called with layer outputs in self.Ys.'''\n",
    "        error = T - self.Ys[-1]\n",
    "        n_samples = X.shape[0]\n",
    "        n_outputs = T.shape[1]\n",
    "        delta = - error / (n_samples * n_outputs)\n",
    "        n_layers = len(self.n_hiddens_per_layer) + 1\n",
    "        # Step backwards through the layers to back-propagate the error (delta)\n",
    "        for layeri in range(n_layers - 1, -1, -1):\n",
    "            # gradient of all but bias weights\n",
    "            self.dE_dWs[layeri][1:, :] = self.Ys[layeri].T @ delta\n",
    "            # gradient of just the bias weights\n",
    "            self.dE_dWs[layeri][0:1, :] = np.sum(delta, 0)\n",
    "            # Back-propagate this layer's delta to previous layer\n",
    "            delta = delta @ self.Ws[layeri][1:, :].T * (1 - self.Ys[layeri] ** 2)\n",
    "            \n",
    "\n",
    "            if self.activation_function == 'tanh':\n",
    "                np.tanh(self.all_gradients)\n",
    "\n",
    "            if self.activation_function == 'relu':\n",
    "                self.grad_relu(self.all_gradients)\n",
    "\n",
    "            \n",
    "        \n",
    "        return self.all_gradients\n",
    "\n",
    "    def use(self, X):\n",
    "        X = (X - self.Xmeans) / self.Xstds\n",
    "        Y = self.forward_pass(X)\n",
    "        T = Y[-1] * self.Tstds + self.Tmeans\n",
    "        return T\n",
    "        \n",
    "    \n",
    "    \n",
    "    \n",
    "def rmse(A, B):\n",
    "    return np.sqrt(np.mean((A - B)**2)) \n",
    "\n",
    "\n",
    "\n",
    "def run_experiment(X, T, n_folds, n_epochs_choices, n_hidden_units_per_layer_choices, activation_function_choices):\n",
    "    Xtrain, Ttrain, Xvalidate, Tvalidate, Xtest, Ttest = partition(X, T, n_folds)\n",
    "    results = []\n",
    "    for rate in [0.01]: # learning rates\n",
    "        for epochs in n_epochs_choices: # Training durations\n",
    "            for nh in n_hidden_units_per_layer_choices: # Layer sizes\n",
    "                for method in activation_function_choices: # Optimizers\n",
    "                    # instantiate and train\n",
    "                    nnet = NeuralNetwork(Xtrain.shape[1], nh, Ttrain.shape[1], activation_function=method)\n",
    "                    nnet.train(Xtrain, Ttrain, epochs, rate, 'adam')\n",
    "                    # append the results of each experiment\n",
    "                    results.append([epochs, nh, rate, method,\n",
    "                                    rmse(Ttrain, nnet.use(Xtrain)),\n",
    "                                    rmse(Tvalidate, nnet.use(Xvalidate)),\n",
    "                                    rmse(Ttest, nnet.use(Xtest))])\n",
    "                    # load these into a dataframe and give it some column titles\n",
    "                    df = pd.DataFrame(results, columns=('epochs', 'nh', 'lr', 'act func', 'RMSE Train',\n",
    "                                                        'RMSE Val', 'RMSE Test'))       \n",
    "    return df\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "df = pd.read_csv('auto-mpg.data-original', delim_whitespace=True, na_values=\"NA\", header=None)\n",
    "df = df.dropna()\n",
    "\n",
    "data = df.iloc[:, :-1].values # view everything except the car names (last column)\n",
    "T = data[:, 0:1]  # data[:,0] results in a one-dimensional matrix, data[:,0:1] preserves its two-dimensional nature.\n",
    "X = data[:, 1:] # give me the input variables\n",
    "\n",
    "pts = 20\n",
    "\n",
    "np.random.seed(42)\n",
    "\n",
    "result_df = run_experiment(X, T, n_folds=5, \n",
    "                           n_epochs_choices=[1000, 2000],\n",
    "                           n_hidden_units_per_layer_choices=[[0], [10], [100, 10]],\n",
    "                           activation_function_choices=['tanh', 'relu'])\n",
    "\n",
    "\n",
    "result_df"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Find the lowest value of `RMSE Val` in your table and report the `RMSE Test` and the parameter values that produced this.  This is your expected error in predicted miles per gallon.  Discuss how good this prediction is."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Plot the RMSE values for training, validation and test sets versus the combined parameter values of number of epochs and network architecture.  Make one plot for `tanh` as the activation function and a second one for `relu`. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Describe at least three different observations you make about these plots.  What do you find interesting?\n",
    "\n",
    "1. ...\n",
    "2. ...\n",
    "3. ..."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Grading and Check-in\n",
    "\n",
    "You and your partner will score of 70 points if your functions are defined correctly. You can test this grading process yourself by downloading [A2grader.zip](https://www.cs.colostate.edu/~cs445/notebooks/A2grader.zip) and extract `A2grader.py` parallel to this notebook.  We recommend keeping this notebook and the grader script in a dedicated folder with *just those two files.* Run the code in the in the following cell to see an example grading run.  If your functions are defined correctly, you should see a score of 70/70.  The remaining 30 points will be based on 1) other testing and the results you obtain, and 2) your discussions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "======================= Code Execution =======================\n",
      "\n",
      "Extracting python code from notebook named 'A2.5 Multilayer Neural Networks for Nonlinear Regression.ipynb' and storing in notebookcode.py\n",
      "Removing all statements that are not function or class defs or import statements.\n",
      "\n",
      "Testing\n",
      "  w = np.array([0.0])\n",
      "  def cubic(wmin):\n",
      "      return (w[0] - wmin) ** 3 + (w[0] - wmin) ** 2\n",
      "  def grad_cubic(wmin):\n",
      "      return 3 * (w[0] - wmin) ** 2 + 2 * (w[0] - wmin)\n",
      "  wmin = 0.5\n",
      "  opt = Optimizers(w)\n",
      "  errors_sgd = opt.sgd(cubic, grad_cubic, [wmin], 100, 0.01)\n",
      "\n",
      "sgd: Epoch 10 Error=0.11889\n",
      "sgd: Epoch 20 Error=0.11092\n",
      "sgd: Epoch 30 Error=0.10176\n",
      "sgd: Epoch 40 Error=0.09162\n",
      "sgd: Epoch 50 Error=0.08081\n",
      "sgd: Epoch 60 Error=0.06972\n",
      "sgd: Epoch 70 Error=0.05879\n",
      "sgd: Epoch 80 Error=0.04844\n",
      "sgd: Epoch 90 Error=0.03901\n",
      "sgd: Epoch 100 Error=0.03072\n",
      "\n",
      "--- 10/10 points. Returned correct value.\n",
      "\n",
      "Testing\n",
      "  w = np.array([0.0])\n",
      "  def cubic(wmin):\n",
      "      return (w[0] - wmin) ** 3 + (w[0] - wmin) ** 2\n",
      "  def grad_cubic(wmin):\n",
      "      return 3 * (w[0] - wmin) ** 2 + 2 * (w[0] - wmin)\n",
      "  wmin = 0.5\n",
      "  opt = Optimizers(w)\n",
      "  errors_adam = opt.adam(cubic, grad_cubic, [wmin], 100, 0.01)\n",
      "\n",
      "Adam: Epoch 10 Error=0.09899\n",
      "Adam: Epoch 20 Error=0.06515\n",
      "Adam: Epoch 30 Error=0.03305\n",
      "Adam: Epoch 40 Error=0.01054\n",
      "Adam: Epoch 50 Error=0.00110\n",
      "Adam: Epoch 60 Error=0.00009\n",
      "Adam: Epoch 70 Error=0.00044\n",
      "Adam: Epoch 80 Error=0.00017\n",
      "Adam: Epoch 90 Error=0.00001\n",
      "Adam: Epoch 100 Error=0.00001\n",
      "\n",
      "--- 10/10 points. Returned correct value.\n",
      "\n",
      "Testing\n",
      "    np.random.seed(42)\n",
      "    \n",
      "    nnet = NeuralNetwork(2, [10], 1)\n",
      "    X = np.arange(40).reshape(20, 2)\n",
      "    T = X[:, 0:1] * X[:, 1:]\n",
      "    nnet.train(X, T, 1000, 0.01, method='adam')\n",
      "\n",
      "Adam: Epoch 100 Error=62.64731\n",
      "Adam: Epoch 200 Error=35.83298\n",
      "Adam: Epoch 300 Error=24.70320\n",
      "Adam: Epoch 400 Error=18.70194\n",
      "Adam: Epoch 500 Error=14.78869\n",
      "Adam: Epoch 600 Error=11.85687\n",
      "Adam: Epoch 700 Error=9.50901\n",
      "Adam: Epoch 800 Error=7.55259\n",
      "Adam: Epoch 900 Error=5.90165\n",
      "Adam: Epoch 1000 Error=4.54391\n",
      "\n",
      "--- 20/20 points. Returned correct value.\n",
      "\n",
      "Testing\n",
      "    np.random.seed(42)\n",
      "    \n",
      "    # Using X and T from previous test\n",
      "    a, b, c, d, e, f = partition(X, T, 3)\n",
      "\n",
      "(8, 2) (8, 1) (6, 2) (6, 1) (6, 2) (6, 1)\n",
      "\n",
      "--- 10/10 points. Returned correct values.\n",
      "\n",
      "Testing\n",
      "    np.random.seed(42)\n",
      "\n",
      "    result = run_experiment(X, T, 3,\n",
      "                            n_epochs_choices=[10, 20],\n",
      "                            n_hidden_units_per_layer_choices=[[0], [10]],\n",
      "                            activation_function_choices=['tanh', 'relu'])\n",
      "\n",
      "    first_test_rmse = result.iloc[0]['RMSE Test']\n",
      "\n",
      "\n",
      "--- 0/20 points. run_experiment raised the exception\n",
      "\n",
      "run_experiment() got an unexpected keyword argument 'n_epochs_choices'\n",
      "\n",
      "======================================================================\n",
      "A2 Execution Grade is 50 / 70\n",
      "======================================================================\n",
      "\n",
      " __ / 30 Discussion of at least three observations about\n",
      "your results.  Please be detailed enough that your conclusions are clear.\n",
      "\n",
      "======================================================================\n",
      "A2 FINAL GRADE is  _  / 100\n",
      "======================================================================\n",
      "\n",
      "Extra Credit:\n",
      "Add the Swish activation function as a third choice in your train function in your NeuralNetwork class. A little googling will find definitions of it and its gradient.\n",
      "\n",
      "Use your run_experiment function to compare results for all three activation functions. Discuss the results.\n",
      "\n",
      "A2 EXTRA CREDIT is 0 / 1\n"
     ]
    }
   ],
   "source": [
    "%run -i A2grader.py"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Name this notebook as `Lastname1-Lastname2-A2.ipynb`| with Lastname1 being then name of the last name of the person who is turning in the notebook.\n",
    "\n",
    "A different but similar grading script will be used to grade your checked-in notebook.  It will include different tests."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Extra Credit: 5 point\n",
    "\n",
    "Add the Swish activation function as a third choice in your `train` function in your `NeuralNetwork` class.\n",
    "A little googling will find definitions of it and its gradient.  Start with [this article](https://www.machinecurve.com/index.php/2019/05/30/why-swish-could-perform-better-than-relu/#todays-activation-functions).\n",
    "\n",
    "Use your `run_experiment` function to compare results for all three activation functions.  Discuss the results."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
